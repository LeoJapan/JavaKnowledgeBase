* [Web3 基础入门]()
    * [一、编程基础](#%E4%B8%80%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)
      * [1.1 介绍](#11-%E4%BB%8B%E7%BB%8D)
      * [1.2 前端技术](#12-%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF)
      * [1.3 后端技术](#13-%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF)
      * [1.4 总结与参考资料]()
    * [二、区块链是什么?](#%E4%BA%8C%E5%8C%BA%E5%9D%97%E9%93%BE%E6%98%AF%E4%BB%80%E4%B9%88)
      * [2.1 理论基础](#21-%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80)
      * [2.2 状态管理(State Management)](#22-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86state-management)
      * [2.3 节点(Nodes)](#23-%E8%8A%82%E7%82%B9nodes)
      * [2.4 去中心化(Decentralization)](#24-%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96decentralization)
      * [2.5 应用](#25-%E5%BA%94%E7%94%A8)
      * [2.6 总结与参考资料](#26-%E6%80%BB%E7%BB%93%E4%B8%8E%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99)
    * [三、Web3是什么?](#%E4%B8%89web3%E6%98%AF%E4%BB%80%E4%B9%88)
      * [3.1 Web1 (1980s - early 2000’s)](#31-web1-1980s---early-2000s)
      * [3.2 What is Web2?](#32-what-is-web2)
      * [3.3 What is Web3?](#33-what-is-web3)
      * [3.4 总结与参考资料](#34-%E6%80%BB%E7%BB%93%E4%B8%8E%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99)
    * [四、以太坊(ETH)是什么?](#%E5%9B%9B%E4%BB%A5%E5%A4%AA%E5%9D%8Aeth%E6%98%AF%E4%BB%80%E4%B9%88)
      * [4.1 理论基础](#41-%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80)
      * [4.2 历史](#42-%E5%8E%86%E5%8F%B2)
      * [4.3 以太(ehter)](#43-%E4%BB%A5%E5%A4%AAehter)
      * [4.4 智能合约(Smart Contracts)](#44-%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6smart-contracts)
      * [4.5 ERC20 Tokens](#45-erc20-tokens)
      * [4.6 ERC721 and ERC1155 Tokens](#46-erc721-and-erc1155-tokens)
      * [4.7 总结与参考资料](#47-%E6%80%BB%E7%BB%93%E4%B8%8E%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99)
     * [五、加密钱包](#%E4%BA%94%E5%8A%A0%E5%AF%86%E9%92%B1%E5%8C%85)
       * [5.1 地址(address)](#51-%E5%9C%B0%E5%9D%80address)
       * [5.2 私钥(private keys)](#52-%E7%A7%81%E9%92%A5private-keys)
       * [5.3 助记词(seed phrase)](#53-%E5%8A%A9%E8%AE%B0%E8%AF%8Dseed-phrase)
       * [5.4 加密钱包(crypto wallet)](#54-%E5%8A%A0%E5%AF%86%E9%92%B1%E5%8C%85crypto-wallet)
       * [5.5 设置加密钱包](#55-%E8%AE%BE%E7%BD%AE%E5%8A%A0%E5%AF%86%E9%92%B1%E5%8C%85)
     * [六、开发IDE REMIX](#%E5%85%AD%E5%BC%80%E5%8F%91ide-remix)
       * [6.1 REMIX介绍](#61-remix%E4%BB%8B%E7%BB%8D)
       * [6.2 REMIX导航](#62-remix%E5%AF%BC%E8%88%AA)
       * [6.3 REMIX工作流](#63-remix%E5%B7%A5%E4%BD%9C%E6%B5%81)
       * [6.4 总结与参考资料](#64-%E6%80%BB%E7%BB%93%E4%B8%8E%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99)
     * [七、Solidity](#%E4%B8%83solidity)
       * [7.1 Solidity介绍](#71-solidity%E4%BB%8B%E7%BB%8D)  
       * [7.2 Solidity基本语法](#72-solidity%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95)  
         * [7.2.1 智能合约初始化](#721-%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%88%9D%E5%A7%8B%E5%8C%96)  
         * [7.2.2 变量和类型](#722-%E5%8F%98%E9%87%8F%E5%92%8C%E7%B1%BB%E5%9E%8B)  
         * [7.2.3 函数、循环和 If/Else](#723-%E5%87%BD%E6%95%B0%E5%BE%AA%E7%8E%AF%E5%92%8C-ifelse)  
         * [7.2.4 数组、字符串](#724-%E6%95%B0%E7%BB%84%E5%AD%97%E7%AC%A6%E4%B8%B2)  
       * [7.3 总结与参考资料](#73-%E6%80%BB%E7%BB%93%E4%B8%8E%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99)  
     * [八、构建你的第一个dApp](#%E5%85%AB%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAdapp)
       * [8.1 准备](#81-%E5%87%86%E5%A4%87)
       * [8.2 创建一个简单的网页](#82-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%BD%91%E9%A1%B5)
       * [8.3 创建一个智能合约](#83-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6)
       * [8.4 连接网页和智能合约](#84-%E8%BF%9E%E6%8E%A5%E7%BD%91%E9%A1%B5%E5%92%8C%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6)
       * [8.5 测试](#85-%E6%B5%8B%E8%AF%95)
       * [8.6 总结](#86-%E6%80%BB%E7%BB%93)
     * [九、使用ERC-20 Token构建您自己的加密货币](#%E4%B9%9D%E4%BD%BF%E7%94%A8erc-20-token%E6%9E%84%E5%BB%BA%E6%82%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8A%A0%E5%AF%86%E8%B4%A7%E5%B8%81)
       * [9.1 ERC-20是什么?](#91-erc-20%E6%98%AF%E4%BB%80%E4%B9%88)  
       * [9.2 先决条件](#92-%E5%85%88%E5%86%B3%E6%9D%A1%E4%BB%B6)  
       * [9.3 编写代码](#93-%E7%BC%96%E5%86%99%E4%BB%A3%E7%A0%81)  
       * [9.4 编译](#94-%E7%BC%96%E8%AF%91)  
       * [9.5 部署](#95-%E9%83%A8%E7%BD%B2)  
       * [9.6 在 Metamask 中查看代币](#96-%E5%9C%A8-metamask-%E4%B8%AD%E6%9F%A5%E7%9C%8B%E4%BB%A3%E5%B8%81)  
       
       
# Web3 基础入门

### 一、编程基础

#### 1.1 介绍
> 开始在 Web3 中构建应用程序，我们需要一些 Web2 的背景知识。 web2 中涵盖了很多主题，这些主题在 Web3 中非常有用。 事实上，就所使用的技术而言，**Web3 是 Web2 的扩展**。  
> 
> 例如，你制定了一个智能合约，你仍然需要为你的用户提供一种与该智能合约进行交互的方式。 您可以通过构建网站或应用程序来实现这一点,允许用户以简单方式与智能合约交互。  
> 
> 此外，您可能还希望在智能合约之外存储一些用户数据或其他数据。 这些概念与 Web2 完全相同，唯一不同的是我们将在后台使用智能合约并与之交互。

#### 1.2 前端技术
> 前端是用户与之交互的界面。 
> 
> 在网络上，前端指的是您可以浏览的网站。 移动应用程序和桌面应用程序也是有效前端界面的示例。使用 HTML、CSS 和 Javascript 等网络技术开发前端界面。 随着学习的深入，React 知识也会很有用。
> 
> + [1. Frontend Development Essentials](https://betterprogramming.pub/frontend-development-the-essentials-1c1290b43590)  
> + [2. Learn Javascript for Free](https://scrimba.com/learn/learnjavascript)  
> + [3. Learn React for Free](https://scrimba.com/learn/learnreact)

#### 1.3 后端技术
> 后端是指软件中允许其运行但不能（不一定）由用户直接访问的部分。  
> 
> 大多数私有数据、用户数据、业务逻辑、数据处理等都发生在后端，而前端仅用于提供该数据的可视化表示，并允许用户使用它执行某些任务。 后端接收来自客户端的请求，并包含将适当数据发送回客户端的逻辑。 后端服务可以用多种编程语言编写——Python、Java、Javascript、Go、Rust 等。
> 
> 在 Web 上，前端网站通常通过 HTTP 通过 Internet 向后端服务器发送请求，请求某些数据或要求它执行特定任务，后端会注册请求并发回响应。

#### 1.4 总结与参考资料
> + [1. What is a backend?](https://www.codecademy.com/article/back-end-architecture)  
> + [2. Building an API with Node.js and Express](https://www.freecodecamp.org/learn/back-end-development-and-apis#basic-node-and-express)  
> + [3. Building an API connected to a database in Node.js](https://www.freecodecamp.org/learn/back-end-development-and-apis/#back-end-development-and-apis-projects)

### 二、区块链是什么?
![Decentralized Ledger](https://i.imgur.com/Pn1B0t8.png)

#### 2.1 理论基础
> 区块链是在计算机网络上的多个节点之间共享的共享、分布式和永久性数据库。 他们以一种不可能修改或破解系统的方式记录数据。  
> 
>正如其同名，区块链将数据记录为区块链。 每个区块都包含一组交易，这些交易可以是在网络中转移资产，也可以是更新存储在区块链上的信息。  
> 
> 区块链由匿名人士（或团体）中本聪在 2009 年发布[Bitcoin Network](https://bitcoin.org/en/)。  
> 比特币是一种加密货币网络，它主要处理 BTC 资产在网络上的转移，没有受信任的中间人或权威机构， 同时确保网络本身是安全的并且不会被黑客入侵。  
> （P.S. 比特币网络也可能是世界上最大的漏洞赏金——如果你能破解它，你就会立即成为万亿富翁）。
> 
> 随着时间的推移，比特币的这种设计激发了其他更强大的区块链网络的出现，比如以太坊。 后续，我们将学习很多关于以太坊的知识。

#### 2.2 状态管理(State Management)
![State Management](https://i.imgur.com/VQySjQu.png)

> 区块链在启动时以 **创世状态(Genesis State)** 开始。   
> 比特币的起源状态发生在 **2009 年**公共网络启动时。 以太坊的创世状态发生在 **2015 年**。
> 
> 区块链上的每笔交易都会修改跨所有节点复制的全局状态(global state)。

![State Management2](https://i.imgur.com/wjK9Foy.png)

> 由于有数百万笔交易，因此交易会以块的形式组合在一起, 由此得名。  
> 
> 这些块以**加密可验证的方式**链接在一起，因此它们在历史上是**可追溯的**。  
> 
> 通过从创世块开始并根据每个块的信息转换状态，可以随时重新计算网络的当前状态。

#### 2.3 节点(Nodes)
> 区块链网络通过计算机节点的对等分布式网络进行自主管理。   
> 无需过多赘述，您可以简单地将网络中的每个节点视为保存一份**全球交易分类帐的副本**。 因此，每个节点都可以单独验证和审计网络上发生的交易，并确保没有非法行为。
> 
> 另一种类型的节点，称为**[挖矿节点](https://en.wikipedia.org/wiki/Bitcoin#Mining)**，负责将网络上进行的新交易组合成一个块，验证它们，并提议将该块包含在其他所有人的全球分类账中。 挖矿在计算上很难，而且安全地进行非常重要，因此区块被接受的矿工将因其辛勤工作而获得象征性奖励。
>
> 区块链的使用证实了**每个单位的价值只被转移了一次**，而中本聪提出的巧妙机制解决了长期存在的去中心化**双重支出问题**。
> 
#### 2.4 去中心化(Decentralization)
> 通过将数据存储在点对点的节点网络中，**区块链是一个去中心化的网络**。 与以集中方式存储数据的传统方法相比，这具有显着的优势。  
> 
> 集中化问题有很多重要的例子——我们将在此处列出其中的一些：  
> + 集中式系统中的数据泄露暴露了大量数据
> + 中心化权威(Centralized authorities)可以审查和关闭言论
> + 依赖中心化权威(Centralized authorities)意味着上游问题会影响下游消费者（例如 AWS 宕机意味着大部分互联网都随之宕机）
> 
> 另一方面，去中心化带来了相反的好处。  
> + 没有审查制度，因为没有单一的权威或中间人可以审查你
> + 没有停机时间，因为整个网络在全球 1000 个节点上运行
> + 高度抗攻击性使其无法操纵或破坏数据

#### 2.5 应用
> + 加密货币(Cryptocurrency)
> + 智能合约(Smart Contracts)
> + 去中心化金融(Decentralized Finance)
> + 赌博(Gaming)
> + 供应链追踪(Supply Chain Tracking)
> + 防伪保护(Counterfeiting Protection)
> + 数据隐私(Data Privacy)
> + 去中心化治理(Decentralized Governance)
> + 可验证的资产所有权(Verifiable ownership of assets)

#### 2.6 总结与参考资料
> [1. But how does bitcoin actually work?](https://www.youtube.com/watch?v=bBC-nXj3Ng4&ab_channel=3Blue1Brown)  
> [2. Blockchain Demo](https://andersbrownworth.com/blockchain/)  
> [3. Secure Hash Algorithms](https://en.wikipedia.org/wiki/Secure_Hash_Algorithms)  
> [4. Byzantine General problem](https://river.com/learn/what-is-the-byzantine-generals-problem/)  
> [5. A Gentle Introduction to Blockchain Technology by Bits On Blocks](https://bitsonblocks.net/2015/09/09/gentle-introduction-blockchain-technology/)  
> [6. How does a blockchain work by Simply Explained](https://www.youtube.com/watch?v=SSo_EIwHSd4&ab_channel=SimplyExplained)


### 三、Web3是什么?

#### 3.1 Web1 (1980s - early 2000’s)
> **Web1.0时代，主要是为日常消费者提供在线的内容和消息。**  
> 作为消费者只能在线阅读信息和内容，还不能与之交互，因此Web1.0极其静态。  
> 当提到Web1.0时，会想到IE,Yahoo或Netscape，所以Web1.0是只读的。

#### 3.2 What is Web2?
> **Web2.0是我们现在所熟悉以及正在使用的版本。**  
> Web1.0是静态的，**只读的**，而Web2.0则是**读写的**，**交互的**。  
> Web2.0是动态的，用户可以自己消费，交互，生产内容。  
> Web2.0的互联网主要由苹果，Aamazon,Facebook和谷歌等4大巨头所领导支配。在Web2.0时代，我们见证了智能手机的普及与爆炸式增长，这也让更多的人参与到互联网，但也意味着互联网也被这些数据信息平台所控制。  
> 
> 那么问题就出现了，什么问题？  
> 在中心化互联网里，Apple公司可以从所有付费App和应用内购买中抽成30%;  
> Twitter和Facebook可以让美国总统去平台化; 
> 而日常消费者的在线消息隐私，安全和控制权低于以往任何时候。  
> 
> 在Web2.0里也出现大量数据泄露事件，导致个人数据安全和隐私性降低。  
> 当用户的数据被泄露时，很容易成为身份盗用，人身攻击等的受害者。

#### 3.3 What is Web3?
> Web3.0是互联网的下一代，一个**去中心化**的互联网。  
> 在Web3.0里，互联网是在线共享的，由集体"我们"来管理，而不是由中心化实体所拥有。  
> Web3.0世界是一个以开源协议为基础的世界。Web3是关于重新构建互联网服务和产品，以便造福于个人而不是实体。
>
> Web3通过使互联网去**中心化、分布式、开放、无需信任和无需许可**，增强了我们今天所知的网络。

#### 3.4 总结与参考资料
> **Web1** 只读  
> **Web2** 读-写  
> **Web3** 读-写-拥有权  

参考资料：
> [1. What is Web3.0](https://www.freecodecamp.org/news/what-is-web3/)  
> [2. Web3 Features and its Comparison Web3 vs Web2](https://www.xenonstack.com/blog/web3-features-and-challenges)  
> [3. WEB2 VS WEB3](https://ethereum.org/en/developers/docs/web2-vs-web3/)  



### 四、以太坊(ETH)是什么?

#### 4.1 理论基础
> 以太坊(Ethereum)是一个支持智能合约的去中心化区块链。  
> 不像比特币(Bitcoin)那样，只支持在网络上比特币代币的传输，而以太坊有更通用的用途。  
> 
> 开发者可以构建运行在EVM(Ehtereum Virtual Machine)的以太坊网络的dApps或者去中心化的应用。  
> 
> 以太坊的全局状态不仅包含每个账户的余额，也包含每个dApp的状态。  
> 
> dApps构建在以太坊上，使用的开发语言是**Solidity**。  
> 也就说可以使用Solidity语言去写智能合约，然后将智能合约部署到以太坊网络。  
> 它通过**权益证明(PoS)**在其网络中的所有计算机之间**保持共识**。  
> 2022年9月推出的Serenity Patch(宁静阶段)使以太坊从工作量证明(PoW)转变为权益证明(PoS)机制。

#### 4.2 历史
> 以太坊最初是由比特币杂志的年轻程序员和联合创始人 ***[Vitalik Buterin(V神)](https://en.wikipedia.org/wiki/Vitalik_Buterin)*** 提出的。  
> 
> 2011年，V神遇到了Bitcoin，也开始为之着迷。他想正式做出贡献，所以他开始写关于它的文章，每篇文章换取几个比特币。2011年底的时候，他共同创办比特币杂志并全职从事加密货币。他周游世界查看各种加密项目，并意识到可以通过将[图灵完备](https://blog.csdn.net/a493823882/article/details/109149332)的通用编程语言集成到区块链中来概括大多数这些项目的功能。
>
> Buterin 试图说服比特币核心开发人员以及其他项目的开发人员，区块链技术可以产生比货币交易更广泛的影响，而区块链需要一种通用的编程语言来配合它。 然而，在被现有项目拒绝后，他决定自己动手。 他继续提出使用图灵完备的编程语言 (Solidity) 开发一个新的区块链平台，这就是我们所知的以太坊。
>
> 2014 年，该项目公开宣布，核心团队由 Vitalik Buterin、Mihai Alise、Anthony Di Iorio、Charles Hoskinson、Joe Lubin 和 Gavin Wood 组成。 几个月后，该团队为 Ether 代币举办了首次代币发行 (ICO) 以资助开发。 该团队筹集了超过 31,000 BTC，当时约为 1800 万美元。 然后，他们成立了以太坊基金会，这是一家位于瑞士的非营利组织，其任务是尽早了解以太坊的开源开发。
> 
#### 4.3 以太(ehter)
> 以太坊有一种本地货币，称为“**以太**”或“**ETH**”。   
> 此代币(token/令牌)用来支付在以太坊网络上完成的交易的交易费用。

#### 4.4 智能合约(Smart Contracts)
> 智能合约是**小型计算机程序**，无需中央协调器即可在以太坊网络上的所有计算机上进行复制和处理。 智能合约允许您编写可由计算机代码自动执行的合约。  
>
> 以太坊的通用性质允许在其之上构建任意数量的可能应用程序，这些应用程序都继承了在以太坊区块链上运行所带来的安全性和去中心化优势。

#### 4.5 ERC20 Tokens
> 除了以太币，人们还可以在以太坊上创建和使用自己的货币。 最常见的货币形式是 ***ERC20 代币***。 ERC20 代币是符合特定标准的智能合约。 开发者可以超越标准，但在制作自己的代币时应满足最低要求。 标准化允许数字钱包轻松支持所有类型的代币，而无需为创建的每个代币编写专门的代码。

#### 4.6 ERC721 and ERC1155 Tokens
> 这些也称为 NFTs。 这两个标准与 ERC20 类似，为创建 NFT 时应满足哪些要求提供了基准线。 它们也提供类似的好处，允许钱包和 NFT 市场立即与所有 NFT 系列兼容，因为它们都遵循这两个标准之一。

#### 4.7 总结与参考资料
> [1. A gentle introduction to Ethereum](https://bitsonblocks.net/2016/10/02/gentle-introduction-ethereum/)  
> [2. Ethereum Whitepaper](https://ethereum.org/en/whitepaper/)  
> [3. ERC-20 Tokens, Explained](https://cointelegraph.com/explained/erc-20-tokens-explained)  
> [4. Smart contracts - Simply Explained](https://www.youtube.com/watch?v=ZE2HxTmxfrI&ab_channel=SimplyExplained)  
> [5. What are Smart Contracts?](https://blockgeeks.com/guides/smart-contracts/)  
> [6. What Are ERC-20 Tokens on the Ethereum Network?](https://www.investopedia.com/news/what-erc20-and-what-does-it-mean-ethereum/)  



### 五、加密钱包

#### 5.1 地址(address)
> **地址**是使用密码学生成的一串文本，代表您在区块链上的账户。  
> 该地址可以与他人公开共享，这样做是完全安全的。 您可以从您的钱包地址发送和接收资金。  
> 基本上，地址是您在区块链上的唯一标识符，代表您的“帐户”。  
> 
> 以太坊地址的一个例子是：**0x01573Df433484fCBe6325a0c6E051Dc62Ab107D1**。

#### 5.2 私钥(private keys)
> 私钥是地址的对应物。 每个地址都有一个关联的私钥。 顾名思义，这是为了保密而不与任何人共享。  
> 
> 你可以把它想象成一个密码，一个非常强大的密码，它包含一堆字母和数字，可以让你**证明对你的地址的所有权**。 任何拥有私钥的人都可以从您的地址进行交易，即从您的地址向他们的地址汇款。  
> 
> 私钥看起来像这样：**E9873D79C6D87DC0FB6A5778633389F4453213303DA61F20BD67FC233AA33262**  
> 
> 如果您将**地址视为帐户的用户名**，那么**私钥就是它的密码**。 因此，分享你的地址是可以的，但永远不要分享你的私钥，否则有人可能会窃取你的资金——然后就无能为力了。  

**注意：由于区块链是分散的，因此没有“忘记密码”选项。 如果您丢失了私钥，您将无法访问您的帐户。 同样，如果有人偷了你的私钥，盗走了你的资金，你也无能为力。 确保此私钥的安全非常重要。**

> 对于开发人员，我们经常使用私钥作为我们代码库的一部分来执行某些交易，例如将我们自己的智能合约部署到以太坊网络。 当您还在学习时，我们强烈**建议您使用一个完全用于开发的单独帐户，而不是用于存储任何类型的资金。**  
> 不幸的是，新手开发者经常使用他们有资金的同一个账户，并且不小心公开分享他们的代码库——黑客可以在代码库中看到你的私钥并最终窃取资金。 请对此谨慎对待，引以为戒。

#### 5.3 助记词(seed phrase)
> 助记词就像主密码——**密码的密码！**  
> 
> 想像为密码管理器，比如 Lastpass 或 1Password。 这些应用程序在其中安全地存储您的其他应用程序的用户名和密码，并且它们本身也有密码。 因此，如果有人破解了您的密码管理器，他们也可以访问其中存储的所有帐户。  
> 
> **加密钱包有点像密码管理器**，您可以在其中管理多个区块链帐户。 如果私钥是单个帐户的密码，则助记词有点像该钱包的主密码。
> 
> 当您创建一个新的加密钱包时，您会看到一个助记词，您应该**绝对安全地存储和备份它**。 您从该钱包内生成的任何新帐户都将链接到助记词。 一个助记词将始终生成相同的帐户，每个帐户具有相同的私钥和地址。
> 
> 例如，如果您创建了一个钱包，然后在其中创建了 5 个帐户，您的助记词将管理所有 5 个帐户。如果您想切换到一个新钱包，您可以分别导入这 5 个钱包 - 通过使用它们各自的私钥 - 或者只使用助记词导入，它会重新生成相同的 5 个帐户。
> 
> 助记词的一个例子是：**dove lumber quote board young robust kit invite plastic regular skull history**

#### 5.4 加密钱包(crypto wallet)
> 加密钱包是您账户的管理者，主要是他们的私钥。 它们还允许您与去中心化应用程序交互，并允许通过钱包连接到 dApp，充当构建在区块链上的所有应用程序的单点登录。


#### 5.5 设置加密钱包
> 对于以太坊，有许多可用的钱包选项。 最容易上手且对开发人员最友好的是 **Metamask** 或 **Coinbase** 钱包。
> 
> 两者都是以太坊加密钱包，可以作为浏览器扩展或移动应用程序安装。   
> 其他替代方案包括 Trust Wallet、Atomic Wallet、Rainbow Wallet、Frame.sh 等。 
> 
> 您可以在下面找到下载链接。   
> [1. Metamask](https://metamask.io/download/)  
> [2. Coinbase Wallet](https://www.coinbase.com/wallet)  
> [3. Rainbow Wallet](https://rainbow.me/)  
> [4. Trust Wallet](https://trustwallet.com/)  
> [5. Atomic Wallet](https://atomicwallet.io/)  
> [6. Frame.sh](https://frame.sh/)  


### 六、开发IDE REMIX
![REMIX IDE](https://user-images.githubusercontent.com/16539849/173646901-81144afc-36aa-418c-be7f-70477b627ced.png)

#### 6.1 REMIX介绍
> Remix Solidity IDE 是一款**基于浏览器的IDE**。
> 它用于开发智能合约，也是目前比较推荐的一款开发以太坊智能合约的IDE，特别是对于新手来说。由于是基于浏览器的IDE，有一个很大的好处就是不用安装，也不用去安装Solidity运行环境，打开即用。
> 
> 官方网址：https://remix.ethereum.org/
> 
> Solidity IDE Remix(在线浏览器编辑器)提供在线编辑Solidity代码、基本的编译、部署至本地或测试网络、执行合约等功能。它是最早在以太坊上构建的开发工具，并拥有大量的扩展插件。

#### 6.2 REMIX导航
> 在左侧边栏中，您可以在<kbd><b>File Explorer(文件资源管理器)</b></kbd>、<kbd><b>Solidity Compiler(Solidity 编译器)</b></kbd>、<kbd><b>Deployer(部署器)</b></kbd>和<kbd><b>扩展面板</b></kbd>之间切换。  
> 在底部，有一个输出面板，显示编译、部署和函数调用的输出。  
> 中间是您将编辑代码的地方。 目前它显示的是 IDE 的主屏幕，但一旦我们打开一个文件，它就会变成代码编辑器。  

![REMIX导航](https://i.imgur.com/4RqBi40.png)

#### 6.3 REMIX工作流
> 在边栏中，如果您在<kbd><b>contracts</b></kbd>文件夹下查看 - Remix 附带 3 个基本智能合同，以帮助人们学习 Solidity。 让我们看一下 <kbd><b>1_Storage.sol</b></kbd>。

![1_Storage.sol](https://i.imgur.com/OdGQABf.png)

> 在文件资源管理器中，我们还可以看到创建新文件或目录、上传本地文件或从 Github 导入文件的选项。
> 
> 为了编译我们的合约，我们转到 <kbd><b>Solidity Compiler</b></kbd> 选项卡，我们将在侧边栏中看到类似这样的内容。

![Solidity Compiler](https://i.imgur.com/kr0a26J.png)

> 在这里，我们可以选择我们想要的<kbd><b>Compiler Version</b></kbd>，我们正在使用的智能合约编程语言（大多数情况下你只会使用 Solidity），以及一些进一步的配置选项。

注意：Remix 中列出的另一种编程语言 <kbd><b>Yul</b></kbd> 是一种低级语言。 它用于中间编译，比 Solidity 更接近硬件。 99% 的时间你不会在 Yul 中编码。 在此处阅读有关 Yul 的更多信息 - [https://docs.soliditylang.org/en/v0.8.9/yul.html](https://docs.soliditylang.org/en/v0.8.9/yul.html)

> 单击 <kbd><b>Compile 1_Storage.sol</b></kbd> 将编译合约并使其准备好部署。

![Compile 1_Storage.sol](https://i.imgur.com/KieTxyw.png)

> 移至 <kbd><b>Deployment</b></kbd> 选项卡，我们将在侧边栏中看到类似这样的内容。

![Deployment](https://i.imgur.com/svMiVS3.png)

> 这里首先要注意的是<kbd><b>Environment</b></kbd>。 Remix 附带一个 <kbd><b>Remix VM（London）</b></kbd>——它是在浏览器中运行 London Upgrade的以太坊虚拟机 (EVM) 的模拟器。 这允许快速测试和调试你的智能合约，只要你的合约不依赖于部署到真实以太坊网络的另一个合约。 值得庆幸的是，我们的存储合约没有，所以我们可以在 Remix VM 中对其进行测试。  
> 
> 要部署到实际网络，我们需要将<kbd><b>Environment</b></kbd> 更改为此处列出的其他选项之一。
>
> 与 <kbd><b>Remix VM（London）</b></kbd>一起，Remix 创建了一组假账户，全部加载了 100 ETH，用于测试。
> 
> 从下拉列表中选择 <kbd><b>1_Storage.sol</b></kbd> 合同，然后单击<kbd><b>Deploy</b></kbd>以部署合同。
> 
> 部署合约后，您将在<kbd><b>Deployed Contracts</b></kbd>部分看到它。
> - 现在可以在其中调用智能合约上的函数。
> 
> 调用 <kbd><b>retrieve</b></kbd> 函数将立即返回 <kbd><b>0</b></kbd> 值，这是 Solidity 中整数的默认值。

![Deployed Contracts](https://i.imgur.com/B0tBUt0.png)

> 同样，我们在输出面板中看到一些关于调用 <kbd><b>Storage.store</b></kbd> 的日志。 现在，如果我们再次尝试<kbd><b>retrieve</b></kbd>，输出将为 <kbd><b>5</b></kbd>。

![Storage.store](https://i.imgur.com/m3BwJCc.png)

> **注意 - 我们进行的这些函数调用/交易都没有打开您的数字钱包 (Metamask)。 这是因为我们目前正在 <kbd><b>Remix VM（London）</b></kbd>中进行测试，而这只是一个使用假账户的模拟器。 当部署到真实网络（测试网或主网）时，交易需要通过您的数字钱包进行确认和签名。**

#### 6.4 总结与参考资料
> 1. 浏览 [Remix IDE Docs 中的文档](https://remix-ide.readthedocs.io/en/latest/)  
> 2. 使用 Remix 附带的默认智能合约来处理工作流程



### 七、Solidity
![Solidity](https://user-images.githubusercontent.com/16539849/173656651-a46df615-8ec3-43fd-9619-98647a6d2bd2.png)

#### 7.1 Solidity介绍
> **Solidity** 是一种面向对象的高级语言，用于实现智能合约。 它旨在针对以太坊虚拟机（EVM）
> 
> 它是静态类型的，支持继承、库和复杂的用户自定义类型等特性。

#### 7.2 Solidity基本语法

* ##### 7.2.1 智能合约初始化
> 
```Solidity
// Define the compiler version you would be using
pragma solidity ^0.8.10;

// Start by creating a contract named HelloWorld
contract HelloWorld {

}
```
* ##### 7.2.2 变量和类型
> Solidity 中有 3 种类型的变量  
>    * 1). Local(局部的)  
>       * 在函数内部声明，不存储在区块链上
>    * 2). State(状态的)  
>       * 在函数外声明以维护智能合约的状态
>       * 存储在区块链上
>    * 3). Global(全局的)  
>       * 提供有关区块链的信息。 它们在运行时由以太坊虚拟机注入。
>       * 包括交易发送者、区块时间戳、区块哈希等
>       * [全局变量的例子](https://docs.soliditylang.org/en/v0.8.17/units-and-global-variables.html)
> 
> 变量的范围决定于声明它们的位置，而不是它们的值。  
> 将局部变量的值设置为全局变量并不会使其成为全局变量，因为它仍然只能在其范围内访问。
```Solidity
// Define the compiler version you would be using
pragma solidity ^0.8.10;

// Start by creating a contract named Variables
contract Variables {
    /*
        ******** State variables **********
    */
    /*
    uint stands for unsigned integer, meaning non negative integers
    different sizes are available. Eg
        - uint8   ranges from 0 to 2 ** 8 - 1
        - uint256 ranges from 0 to 2 ** 256 - 1
    `public` means that the variable can be accessed internally
     by the contract and can also be read by the external world
    */
    uint8 public u8 = 10;
    uint public u256 = 600;
    uint public u = 1230; // uint is an alias for uint256

    /*
    Negative numbers are allowed for int types. Eg
    - int256 ranges from -2 ** 255 to 2 ** 255 - 1
    */
    int public i = -123; // int is same as int256

    // address stands for an ethereum address
    address public addr = 0xCA35b7d915458EF540aDe6068dFe2F44E8fa733c;

    // bool stands for boolean
    bool public defaultBoo1 = false;

    // Default values
    // Unassigned variables have a default value in Solidity
    bool public defaultBoo2; // false
    uint public defaultUint; // 0
    int public defaultInt; // 0
    address public defaultAddr; // 0x0000000000000000000000000000000000000000

    function doSomething() public {
        /*
        ******** Local variable **********
        */
        uint ui = 456;

        /*
        ******** Global variables **********
        */

        /*
            block.timestamp tells us whats the timestamp for the current block
            msg.sender tells us which address called the doSomething function
        */
        uint timestamp = block.timestamp; // Current block timestamp
        address sender = msg.sender; // address of the caller
    }
}
```
> * ##### 7.2.3 函数、循环和 If/Else
```Solidity
// Define the compiler version you would be using
pragma solidity ^0.8.10;

// Start by creating a contract named Conditions
contract Conditions {
    // State variable to store a number
    uint public num;

    /*
        Name of the function is set.
        It takes in an uint and sets the state variable num.
        It is declared as a public function meaning
        it can be called from within the contract and also externally.
    */
    function set(uint _num) public {
        num = _num;
    }

    /*
        Name of the function is get.
        It returns the value of num.
        It is declared as a view function meaning
        that the function doesn't change the state of any variable.
        view functions in solidity do not require gas.
    */
    function get() public view returns (uint) {
        return num;
    }

    /*
        Name of the function is foo.
        It takes in an uint and returns an uint.
        It compares the value of x using if/else
    */
    function foo(uint x) public returns (uint) {
        if (x < 10) {
            return 0;
        } else if (x < 20) {
            return 1;
        } else {
            return 2;
        }
    }

    /*
        Name of the function is loop.
        It runs a loop till 10
    */
    function loop() public {
        // for loop
        for (uint i = 0; i < 10; i++) {
            if (i == 3) {
                // Skip to next iteration with continue
                continue;
            }
            if (i == 5) {
                // Exit loop with break
                break;
            }
        }
    }


}
```

> * ##### 7.2.4 数组、字符串
> **数组可以具有编译时固定大小或动态大小。**
```Solidity
pragma solidity ^0.8.10;

contract Array {

    // Declare a string variable which is public
    string public greet = "Hello World!";
    // Several ways to initialize an array
    // Arrays initialized here are considered state variables that get stored on the blockchain
    // These are called storage variables
    uint[] public arr;
    uint[] public arr2 = [1, 2, 3];
    // Fixed sized array, all elements initialize to 0
    uint[10] public myFixedSizeArr;
    /*
        Name of the function is get
        It gets the value of element stored in an array's index
    */
    function get(uint i) public view returns (uint) {
        return arr[i];
    }

    /*
     Solidity can return the entire array.
     This function gets called with and returns an uint[] memory.
     memory - the value is stored only in memory, and not on the blockchain
              it only exists during the time the function is being executed

     Memory variables and Storage variables can be thought of as similar to RAM vs Hard Disk.
     Memory variables exist temporarily, during function execution, whereas Storage variables
     are persistent across function calls for the lifetime of the contract.
     Here the array is only needed for the duration while the function executes and thus is declared as a memory variable
    */
    function getArr(uint[] memory _arr) public view returns (uint[] memory) {
        return _arr;
    }

     /*
        This function returns string memory.
        The reason memory keyword is added is because string internally works as an array
        Here the string is only needed while the function executes.
    */
    function foo() public returns (string memory) {
        return "C";
    }

    function doStuff(uint i) public {
        // Append to array
        // This will increase the array length by 1.
        arr.push(i);
        // Remove last element from array
        // This will decrease the array length by 1
        arr.pop();
        // get the length of the array
        uint length = arr.length;
        // Delete does not change the array length.
        // It resets the value at index to it's default value,
        // in this case it resets the value at index 1 in arr2 to 0
        uint index = 1;
        delete arr2[index];
        // create array in memory, only fixed size can be created
        uint[] memory a = new uint[](5);
        // create string in memory
        string memory hi = "hi";
    }

 }
```
#### 7.3 总结与参考资料
> 1. [Solidity by Example](https://solidity-by-example.org/)  
> 2. [Cryptozombies](https://cryptozombies.io/)是在编游戏的过程中学习 Solidity 智能合约协议语言的互动教程。  
> 3. [Solidity docs](https://docs.soliditylang.org/en/v0.8.17/)  



### 八、构建你的第一个dApp
> 我们将使用Metamask、Remix IDE 和 Ethers.js来创建前端，部署Solidity智能合约并将它们连接在一起。
> 
> 在本教程结束时，将能够创建一个简单的 HTML 前端，其中包含可以与智能合约功能进行交互的按钮。 教程分 3 个阶段进行
>    * 1. Create a basic HTML web page
>    * 2. Create a basic Solidity smart contract
>    * 3. Connect the web page with the smart contracts using Ethers.js.

[![Build your first dApp](https://i.imgur.com/pDcYqIg.png)](https://www.youtube.com/watch?v=aqxAWLi6UMA&ab_channel=LearnWeb3DAO)

#### 8.1 准备
> **1. 下载并安装[MetaMask](https://metamask.io/)**  
> 参考视频[MetaMask Wallet Tutorial](https://www.youtube.com/watch?v=wlm4QcA8c4Q&t=66s&ab_channel=EveryBitHelps)  
> 主要参考时间区间<kbd><b>1:06 to 4:14</b></kbd>  
> 登录MetaMask电子钱包后，将头部的**以太坊主网**切换到**Goerli测试网络**


> **2. 从Faucet(水龙头)请求Goerli测试网络的以太代币并导入到MetaMask电子钱包**  
> * [请求测试网以太代币的Faucet水龙头连接](https://faucets.chain.link/)  
> * [Faucet水龙头的解释和使用](https://blog.b9lab.com/when-we-first-built-our-faucet-we-deployed-it-on-the-morden-testnet-70bfbf4e317e)  


> **3. 安装开发工具[Visual Studio Code](https://code.visualstudio.com/)**  
> 
> VS code的推荐安装插件如下：
> * [Solidity](https://marketplace.visualstudio.com/items?itemName=NomicFoundation.hardhat-solidity) - Solidity 的语法高亮显示  
> * [Live Server](https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer) - 允许您运行本地服务器来测试您的 HTML/CSS/JS 文件  
> * [Prettier](https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode) - JS、CSS 和 HTML 文件的代码格式化  
> * [npm IntelliSense](https://marketplace.visualstudio.com/items?itemName=christian-kohler.npm-intellisense) - 在 import 语句中自动完成 npm 模块  
> * [IntelliSense for CSS class names in HTML](https://marketplace.visualstudio.com/items?itemName=Zignd.html-css-class-completion) - 自动完成 HTML 文件中的 CSS 类  
> * [GitLens](https://marketplace.visualstudio.com/items?itemName=eamodio.gitlens) - 在编辑器中显示 git blame 信息  


> **4. 安装 HTTP 服务器，建议初学者使用 lite-server**  
> * 安装[Node.js](https://nodejs.org/en/download/)  
> * 安装 lite-server（在终端/命令提示符中使用 NPM）：  

##### 注意:如果已经安装Live Server插件的话，可以跳过此步骤  

```Solidity
# This installs `lite-server` globally (-g) on your computer
npm install -g lite-server
```


#### 8.2 创建一个简单的网页
> 1. 先写个HTML页面吧

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>My First dApp</title>
    <style>
        body {
          text-align: center;
          font-family: Arial, Helvetica, sans-serif;
        }
      
        div {
          width: 20%;
          margin: 0 auto;
          display: flex;
          flex-direction: column;
        }
      
        button {
          width: 100%;
          margin: 10px 0px 5px 0px;
        }
      </style>
  </head>
  <body>
    <div>
      <h1>This is my dApp!</h1>
      <p>Here we can set or get the mood:</p>
      <label for="mood">Input Mood:</label> <br />
      <input type="text" id="mood" />
      <button onclick="getMood()">Get Mood</button>
      <button onclick="setMood()">Set Mood</button>
    </div>
  </body>
</html> 
```

> 2. 本地终端启动服务，测试上面写好的index.html页面  
>  例:http://127.0.0.1:5500/Web3.0/01_Freshman/html/index.html

#### 8.3 创建一个智能合约
> 1. 使用[Remix](https://remix.ethereum.org/)来创建一个智能合约  

```Solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.1;

contract MoodDiary{
  // This is the contract's body, here you'll specify the logic for this contract.

  string mood;

  //create a function that writes a mood to the smart contract
  function setMood(string memory _mood) public {
    mood = _mood;
  }

  //create a function that reads the mood from the smart contract
  function getMood() public view returns(string memory){
    return mood;
  }
}
```

> 2. 将智能合约部署到Goerli测试网络。
>    * 确认电子钱包(Metamask)连接到Goerli测试网络
>    * 为Solidity智能合约选择一致匹配的编译版本(在Solidity Compiler选项卡)
>    * 编译Solidity智能合约(可能会花一点时间)
>    * 编译后，才能在Deploy and Run Transactions选项卡里部署智能合约
>    * 部署智能合约前，由于要部署到Goerli测试网络上，ENVIRONMENT参数里选择<kbd><b>Injected Provider - MetaMask</b></kbd>(将事务部署到自己Metamask里)
>    * 部署智能合约时，会弹出智能钱包连接确认页面，确认即可(也需要等待一点时间)
>    * 智能合约部署成功后，Deployed Contracts选项页面里会现setMood和getMood的方法测试页面，可以先setMood，然后getMood来测试智能合约

> 3. 为了后续连接页面和智能合约，需要保存一些参数值，在页面调用时使用  
>    * 部署的智能合约地址
>        * 在上述Deployed Contracts选项页面，可以点击copy按钮来负复制地址，例如：<kbd><b>0xE855A774bB5b4a048CA72ad338B235b7A2E145ed</b></kbd>
>    * 智能合约ABI - [contract ABI](https://docs.soliditylang.org/en/develop/abi-spec.html)
>        * 在Solidity Compiler选项卡底部，可以点击<kbd><b>ABI</b></kbd>按钮来复制获取ABI

#### 8.4 连接网页和智能合约
返回到<kbd><b>index.html</b></kbd>页面，添加Javascript代码来建立连接。
> 1. index.html页面里导入<kbd><b>Ethers.js</b></kbd>源码

```Html
<script
  src="https://cdn.ethers.io/lib/ethers-5.2.umd.min.js"
  type="application/javascript"></script>

<script>
  ////////////////////
  //ADD YOUR CODE HERE
  ////////////////////
</script>
```

> 2. 导入contract [ABI](https://docs.soliditylang.org/en/develop/abi-spec.html)

```Javascript
  const MoodContractAddress = "<contract address>";
  const MoodContractABI = <contract ABI>
  let MoodContract;
  let signer;
```

> 对于contract ABI,属于JSON格式，可参照具体[JSON字段](https://docs.soliditylang.org/en/develop/abi-spec.html#json)来进行理解  
> 由于此次例子有2个方法，所以应该是一个数组，格式大致如下


```Javascript
const MoodContractABI = [{}, {}]
```
> 上述页面，每个对象有如下的字段：<kbd><b>constant</b></kbd>，<kbd><b>inputs</b></kbd>，<kbd><b>name</b></kbd>，<kbd><b>outputs</b></kbd>，<kbd><b>payable</b></kbd>，<kbd><b>stateMutability </b></kbd>and <kbd><b>type</b></kbd>。

我的ContractABI如下：
```Javascript
const MoodContractABI = [
	{
		"inputs": [],
		"name": "getMood",
		"outputs": [
			{
				"internalType": "string",
				"name": "",
				"type": "string"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "string",
				"name": "_mood",
				"type": "string"
			}
		],
		"name": "setMood",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	}
]
```
> 3. 在页面里定义[提供者Provider](https://learnblockchain.cn/docs/ethers.js/api-providers.html),此处的例子用的是**Goerli**。
```Javascript
const provider = new ethers.providers.Web3Provider(window.ethereum, "goerli");
```
> 4. 请求访问用户的钱包并将签名者连接到您的 metamask 帐户（我们使用 [0] 作为默认值），并使用您的合约地址、ABI 和签名者定义合约对象
```Javascript
provider.send("eth_requestAccounts", []).then(() => {
  provider.listAccounts().then((accounts) => {
    signer = provider.getSigner(accounts[0]);
    MoodContract = new ethers.Contract(
      MoodContractAddress,
      MoodContractABI,
      signer
    );
  });
});
```

> 4. 创建异步函数来调用您的智能合约函数
```Javascript
async function getMood() {
  const getMoodPromise = MoodContract.getMood();
  const Mood = await getMoodPromise;
  console.log(Mood);
}

async function setMood() {
  const mood = document.getElementById("mood").value;
  const setMoodPromise = MoodContract.setMood(mood);
  await setMoodPromise;
}
```

> 6. 将您的功能连接到您的 html 按钮
```Html
<button onclick="getMood()">Get Mood</button>
<button onclick="setMood()">Set Mood</button>
```

#### 8.5 测试
> 1. 启动Server,测试index.html(我的例子：http://127.0.0.1:5500/Web3.0/01_Freshman/html/index.html)
> 2. 测试函数，首先调用setMood函数，输入测试值，然后点击setMood按钮(弹出连接电子钱包，需要15秒左右)  
> 3. 在调用getMood函数前，按F12调出开发者工具界面，打开console后台管理页面，然后在点击getMood按钮，会将前面输入的测试值打印到console控制台上  
> 4. 智能合约确认是否部署成功的网址[https://goerli.etherscan.io/](https://goerli.etherscan.io/)


#### 8.6 总结
> 自己编写时遇到困扰自己调试不通的问题就是Address，这个地址分为**钱包地址**和**智能合约地址**，每次部署后的智能合约地址不同，页面里调用的区块链应该也是不同的
>
> 我的参考例子代码：
> * 智能合约[mood.sol](https://github.com/LeoJapan/MyKnowledgeBase/blob/main/Web3.0/01_Freshman/contracts/mood.sol)  
> * 测试Html页面[index.html](https://github.com/LeoJapan/MyKnowledgeBase/blob/main/Web3.0/01_Freshman/html/index.html)



### 九、使用ERC-20 Token构建您自己的加密货币

本章节使用Metamask和Remix IDE来创建一个以太坊ERC-20代币  

[![Build your own cryptocurrency](https://i.imgur.com/RVzkVsZ.png)](https://www.youtube.com/watch?v=5yM5bojHbmQ&ab_channel=LearnWeb3DAO)
#### 9.1 ERC-20是什么?
> ERC全称是“Ethereum Request for Comment”,表示以太坊开发者提交的协议提案。  
> 从本质上讲，它们是社区认可的标准，用于传达特定用例的技术要求和规范。  

> ERC-20 是一个概述同质化代币的技术规范的标准。
> 可替代性是所有代币的属性其中的一部分，都是相同的。将 1 ETH 换成不同的 1 ETH 不会改变任何东西，你还有 1 ETH。 因此，ETH 是一种可替代的代币。 所有法定货币也是可替代的。

> **NFT 是不可替代代币的示例（稍后会详细介绍），其中每个代币都不同于不同的代币。**

> 以太坊上的大多数代币都符合 ERC-20 规范。 遵循像 ERC-20 这样的标准，允许使用 ERC-20 代币的应用程序开发人员轻松支持所有 ERC-20 代币，而无需单独为它们编写专门的代码。

> 例如，像 Uniswap 这样的去中心化交易所允许您用任何代币交换任何其他代币。 这是可能的，因为几乎所有代币都遵循 ERC-20 标准，因此 Uniswap 可以编写适用于所有符合标准的代币的代码。
#### 9.2 先决条件
> * 确保您已经下载并安装了 [Metamask](https://metamask.io/)。  
> * 选择要使用的 <kbd><b>Goerli Testnet</kbd></b> 网络
> * 通过以下任一水龙头在 Goerli 上请求一些测试网以太币：  
>   * [Metamask Faucet](https://faucet.metamask.io/)   
>   * [Chainlink Faucet](https://faucets.chain.link/) 
>   * [Paradigm Faucet](https://faucet.paradigm.xyz/) 
#### 9.3 编写代码

#### 9.4 编译

#### 9.5 部署

#### 9.6 在 Metamask 中查看代币
