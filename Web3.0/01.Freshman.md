* [Web3 基础入门]()
    * [一、编程基础](#%E4%B8%80%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)
      * [1.1 介绍](#11-%E4%BB%8B%E7%BB%8D)
      * [1.2 前端技术](#12-%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF)
      * [1.3 后端技术](#13-%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF)
      * [1.4 总结与参考资料]()
    * [二、区块链是什么?](#%E4%BA%8C%E5%8C%BA%E5%9D%97%E9%93%BE%E6%98%AF%E4%BB%80%E4%B9%88)
      * [2.1 理论基础](#21-%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80)
      * [2.2 状态管理(State Management)](#22-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86state-management)
      * [2.3 节点(Nodes)](#23-%E8%8A%82%E7%82%B9nodes)
      * [2.4 去中心化(Decentralization)](#24-%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96decentralization)
      * [2.5 应用](#25-%E5%BA%94%E7%94%A8)
      * [2.6 总结与参考资料](#26-%E6%80%BB%E7%BB%93%E4%B8%8E%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99)
    * [三、Web3是什么?](#%E4%B8%89web3%E6%98%AF%E4%BB%80%E4%B9%88)
      * [3.1 Web1 (1980s - early 2000’s)](#31-web1-1980s---early-2000s)
      * [3.2 What is Web2?](#32-what-is-web2)
      * [3.3 What is Web3?](#33-what-is-web3)
      * [3.4 总结与参考资料](#34-%E6%80%BB%E7%BB%93%E4%B8%8E%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99)
    * [四、以太坊(ETH)是什么?](#%E5%9B%9B%E4%BB%A5%E5%A4%AA%E5%9D%8Aeth%E6%98%AF%E4%BB%80%E4%B9%88)
      * [4.1 理论基础](#41-%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80)
      * [4.2 历史](#42-%E5%8E%86%E5%8F%B2)
      * [4.3 以太(ehter)](#43-%E4%BB%A5%E5%A4%AAehter)
      * [4.4 智能合约(Smart Contracts)](#44-%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6smart-contracts)
      * [4.5 ERC20 Tokens](#45-erc20-tokens)
      * [4.6 ERC721 and ERC1155 Tokens](#46-erc721-and-erc1155-tokens)
      * [4.7 总结与参考资料](#47-%E6%80%BB%E7%BB%93%E4%B8%8E%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99)
     * [五、加密钱包](#%E4%BA%94%E5%8A%A0%E5%AF%86%E9%92%B1%E5%8C%85)
       * [5.1 地址(address)](#51-%E5%9C%B0%E5%9D%80address)
       * [5.2 私钥(private keys)](#52-%E7%A7%81%E9%92%A5private-keys)
       * [5.3 助记词(seed phrase)](#53-%E5%8A%A9%E8%AE%B0%E8%AF%8Dseed-phrase)
       * [5.4 加密钱包(crypto wallet)](#54-%E5%8A%A0%E5%AF%86%E9%92%B1%E5%8C%85crypto-wallet)
       * [5.5 设置加密钱包](#55-%E8%AE%BE%E7%BD%AE%E5%8A%A0%E5%AF%86%E9%92%B1%E5%8C%85)
     * [六、开发IDE REMIX](#%E5%85%AD%E5%BC%80%E5%8F%91ide-remix)
        * [6.1 REMIX介绍](#61-remix%E4%BB%8B%E7%BB%8D)
        * [6.2 REMIX导航](#62-remix%E5%AF%BC%E8%88%AA)
        * [6.3 REMIX工作流](#63-remix%E5%B7%A5%E4%BD%9C%E6%B5%81)
        * [6.4 总结与参考资料](#64-%E6%80%BB%E7%BB%93%E4%B8%8E%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99)
      
# Web3 基础入门

### 一、编程基础

#### 1.1 介绍
> 开始在 Web3 中构建应用程序，我们需要一些 Web2 的背景知识。 web2 中涵盖了很多主题，这些主题在 Web3 中非常有用。 事实上，就所使用的技术而言，**Web3 是 Web2 的扩展**。  
> 
> 例如，你制定了一个智能合约，你仍然需要为你的用户提供一种与该智能合约进行交互的方式。 您可以通过构建网站或应用程序来实现这一点,允许用户以简单方式与智能合约交互。  
> 
> 此外，您可能还希望在智能合约之外存储一些用户数据或其他数据。 这些概念与 Web2 完全相同，唯一不同的是我们将在后台使用智能合约并与之交互。

#### 1.2 前端技术
> 前端是用户与之交互的界面。 
> 
> 在网络上，前端指的是您可以浏览的网站。 移动应用程序和桌面应用程序也是有效前端界面的示例。使用 HTML、CSS 和 Javascript 等网络技术开发前端界面。 随着学习的深入，React 知识也会很有用。
> 
> + [1. Frontend Development Essentials](https://betterprogramming.pub/frontend-development-the-essentials-1c1290b43590)  
> + [2. Learn Javascript for Free](https://scrimba.com/learn/learnjavascript)  
> + [3. Learn React for Free](https://scrimba.com/learn/learnreact)

#### 1.3 后端技术
> 后端是指软件中允许其运行但不能（不一定）由用户直接访问的部分。  
> 
> 大多数私有数据、用户数据、业务逻辑、数据处理等都发生在后端，而前端仅用于提供该数据的可视化表示，并允许用户使用它执行某些任务。 后端接收来自客户端的请求，并包含将适当数据发送回客户端的逻辑。 后端服务可以用多种编程语言编写——Python、Java、Javascript、Go、Rust 等。
> 
> 在 Web 上，前端网站通常通过 HTTP 通过 Internet 向后端服务器发送请求，请求某些数据或要求它执行特定任务，后端会注册请求并发回响应。

#### 1.4 总结与参考资料
> + [1. What is a backend?](https://www.codecademy.com/article/back-end-architecture)  
> + [2. Building an API with Node.js and Express](https://www.freecodecamp.org/learn/back-end-development-and-apis#basic-node-and-express)  
> + [3. Building an API connected to a database in Node.js](https://www.freecodecamp.org/learn/back-end-development-and-apis/#back-end-development-and-apis-projects)

### 二、区块链是什么?
![Decentralized Ledger](https://i.imgur.com/Pn1B0t8.png)

#### 2.1 理论基础
> 区块链是在计算机网络上的多个节点之间共享的共享、分布式和永久性数据库。 他们以一种不可能修改或破解系统的方式记录数据。  
> 
>正如其同名，区块链将数据记录为区块链。 每个区块都包含一组交易，这些交易可以是在网络中转移资产，也可以是更新存储在区块链上的信息。  
> 
> 区块链由匿名人士（或团体）中本聪在 2009 年发布[Bitcoin Network](https://bitcoin.org/en/)。  
> 比特币是一种加密货币网络，它主要处理 BTC 资产在网络上的转移，没有受信任的中间人或权威机构， 同时确保网络本身是安全的并且不会被黑客入侵。  
> （P.S. 比特币网络也可能是世界上最大的漏洞赏金——如果你能破解它，你就会立即成为万亿富翁）。
> 
> 随着时间的推移，比特币的这种设计激发了其他更强大的区块链网络的出现，比如以太坊。 后续，我们将学习很多关于以太坊的知识。

#### 2.2 状态管理(State Management)
![State Management](https://i.imgur.com/VQySjQu.png)

> 区块链在启动时以 **创世状态(Genesis State)** 开始。   
> 比特币的起源状态发生在 **2009 年**公共网络启动时。 以太坊的创世状态发生在 **2015 年**。
> 
> 区块链上的每笔交易都会修改跨所有节点复制的全局状态(global state)。

![State Management2](https://i.imgur.com/wjK9Foy.png)

> 由于有数百万笔交易，因此交易会以块的形式组合在一起, 由此得名。  
> 
> 这些块以**加密可验证的方式**链接在一起，因此它们在历史上是**可追溯的**。  
> 
> 通过从创世块开始并根据每个块的信息转换状态，可以随时重新计算网络的当前状态。

#### 2.3 节点(Nodes)
> 区块链网络通过计算机节点的对等分布式网络进行自主管理。   
> 无需过多赘述，您可以简单地将网络中的每个节点视为保存一份**全球交易分类帐的副本**。 因此，每个节点都可以单独验证和审计网络上发生的交易，并确保没有非法行为。
> 
> 另一种类型的节点，称为**[挖矿节点](https://en.wikipedia.org/wiki/Bitcoin#Mining)**，负责将网络上进行的新交易组合成一个块，验证它们，并提议将该块包含在其他所有人的全球分类账中。 挖矿在计算上很难，而且安全地进行非常重要，因此区块被接受的矿工将因其辛勤工作而获得象征性奖励。
>
> 区块链的使用证实了**每个单位的价值只被转移了一次**，而中本聪提出的巧妙机制解决了长期存在的去中心化**双重支出问题**。
> 
#### 2.4 去中心化(Decentralization)
> 通过将数据存储在点对点的节点网络中，**区块链是一个去中心化的网络**。 与以集中方式存储数据的传统方法相比，这具有显着的优势。  
> 
> 集中化问题有很多重要的例子——我们将在此处列出其中的一些：  
> + 集中式系统中的数据泄露暴露了大量数据
> + 中心化权威(Centralized authorities)可以审查和关闭言论
> + 依赖中心化权威(Centralized authorities)意味着上游问题会影响下游消费者（例如 AWS 宕机意味着大部分互联网都随之宕机）
> 
> 另一方面，去中心化带来了相反的好处。  
> + 没有审查制度，因为没有单一的权威或中间人可以审查你
> + 没有停机时间，因为整个网络在全球 1000 个节点上运行
> + 高度抗攻击性使其无法操纵或破坏数据

#### 2.5 应用
> + 加密货币(Cryptocurrency)
> + 智能合约(Smart Contracts)
> + 去中心化金融(Decentralized Finance)
> + 赌博(Gaming)
> + 供应链追踪(Supply Chain Tracking)
> + 防伪保护(Counterfeiting Protection)
> + 数据隐私(Data Privacy)
> + 去中心化治理(Decentralized Governance)
> + 可验证的资产所有权(Verifiable ownership of assets)

#### 2.6 总结与参考资料
> [1. But how does bitcoin actually work?](https://www.youtube.com/watch?v=bBC-nXj3Ng4&ab_channel=3Blue1Brown)  
> [2. Blockchain Demo](https://andersbrownworth.com/blockchain/)  
> [3. Secure Hash Algorithms](https://en.wikipedia.org/wiki/Secure_Hash_Algorithms)  
> [4. Byzantine General problem](https://river.com/learn/what-is-the-byzantine-generals-problem/)  
> [5. A Gentle Introduction to Blockchain Technology by Bits On Blocks](https://bitsonblocks.net/2015/09/09/gentle-introduction-blockchain-technology/)  
> [6. How does a blockchain work by Simply Explained](https://www.youtube.com/watch?v=SSo_EIwHSd4&ab_channel=SimplyExplained)


### 三、Web3是什么?

#### 3.1 Web1 (1980s - early 2000’s)
> **Web1.0时代，主要是为日常消费者提供在线的内容和消息。**  
> 作为消费者只能在线阅读信息和内容，还不能与之交互，因此Web1.0极其静态。  
> 当提到Web1.0时，会想到IE,Yahoo或Netscape，所以Web1.0是只读的。

#### 3.2 What is Web2?
> **Web2.0是我们现在所熟悉以及正在使用的版本。**  
> Web1.0是静态的，**只读的**，而Web2.0则是**读写的**，**交互的**。  
> Web2.0是动态的，用户可以自己消费，交互，生产内容。  
> Web2.0的互联网主要由苹果，Aamazon,Facebook和谷歌等4大巨头所领导支配。在Web2.0时代，我们见证了智能手机的普及与爆炸式增长，这也让更多的人参与到互联网，但也意味着互联网也被这些数据信息平台所控制。  
> 
> 那么问题就出现了，什么问题？  
> 在中心化互联网里，Apple公司可以从所有付费App和应用内购买中抽成30%;  
> Twitter和Facebook可以让美国总统去平台化; 
> 而日常消费者的在线消息隐私，安全和控制权低于以往任何时候。  
> 
> 在Web2.0里也出现大量数据泄露事件，导致个人数据安全和隐私性降低。  
> 当用户的数据被泄露时，很容易成为身份盗用，人身攻击等的受害者。

#### 3.3 What is Web3?
> Web3.0是互联网的下一代，一个**去中心化**的互联网。  
> 在Web3.0里，互联网是在线共享的，由集体"我们"来管理，而不是由中心化实体所拥有。  
> Web3.0世界是一个以开源协议为基础的世界。Web3是关于重新构建互联网服务和产品，以便造福于个人而不是实体。
>
> Web3通过使互联网去**中心化、分布式、开放、无需信任和无需许可**，增强了我们今天所知的网络。

#### 3.4 总结与参考资料
> **Web1** 只读  
> **Web2** 读-写  
> **Web3** 读-写-拥有权  

参考资料：
> [1. What is Web3.0](https://www.freecodecamp.org/news/what-is-web3/)  
> [2. Web3 Features and its Comparison Web3 vs Web2](https://www.xenonstack.com/blog/web3-features-and-challenges)  
> [3. WEB2 VS WEB3](https://ethereum.org/en/developers/docs/web2-vs-web3/)  



### 四、以太坊(ETH)是什么?

#### 4.1 理论基础
> 以太坊(Ethereum)是一个支持智能合约的去中心化区块链。  
> 不像比特币(Bitcoin)那样，只支持在网络上比特币代币的传输，而以太坊有更通用的用途。  
> 
> 开发者可以构建运行在EVM(Ehtereum Virtual Machine)的以太坊网络的dApps或者去中心化的应用。  
> 
> 以太坊的全局状态不仅包含每个账户的余额，也包含每个dApp的状态。  
> 
> dApps构建在以太坊上，使用的开发语言是**Solidity**。  
> 也就说可以使用Solidity语言去写智能合约，然后将智能合约部署到以太坊网络。  
> 它通过**权益证明(PoS)**在其网络中的所有计算机之间**保持共识**。  
> 2022年9月推出的Serenity Patch(宁静阶段)使以太坊从工作量证明(PoW)转变为权益证明(PoS)机制。

#### 4.2 历史
> 以太坊最初是由比特币杂志的年轻程序员和联合创始人 ***[Vitalik Buterin(V神)](https://en.wikipedia.org/wiki/Vitalik_Buterin)*** 提出的。  
> 
> 2011年，V神遇到了Bitcoin，也开始为之着迷。他想正式做出贡献，所以他开始写关于它的文章，每篇文章换取几个比特币。2011年底的时候，他共同创办比特币杂志并全职从事加密货币。他周游世界查看各种加密项目，并意识到可以通过将[图灵完备](https://blog.csdn.net/a493823882/article/details/109149332)的通用编程语言集成到区块链中来概括大多数这些项目的功能。
>
> Buterin 试图说服比特币核心开发人员以及其他项目的开发人员，区块链技术可以产生比货币交易更广泛的影响，而区块链需要一种通用的编程语言来配合它。 然而，在被现有项目拒绝后，他决定自己动手。 他继续提出使用图灵完备的编程语言 (Solidity) 开发一个新的区块链平台，这就是我们所知的以太坊。
>
> 2014 年，该项目公开宣布，核心团队由 Vitalik Buterin、Mihai Alise、Anthony Di Iorio、Charles Hoskinson、Joe Lubin 和 Gavin Wood 组成。 几个月后，该团队为 Ether 代币举办了首次代币发行 (ICO) 以资助开发。 该团队筹集了超过 31,000 BTC，当时约为 1800 万美元。 然后，他们成立了以太坊基金会，这是一家位于瑞士的非营利组织，其任务是尽早了解以太坊的开源开发。
> 
#### 4.3 以太(ehter)
> 以太坊有一种本地货币，称为“**以太**”或“**ETH**”。   
> 此代币(token/令牌)用来支付在以太坊网络上完成的交易的交易费用。

#### 4.4 智能合约(Smart Contracts)
> 智能合约是**小型计算机程序**，无需中央协调器即可在以太坊网络上的所有计算机上进行复制和处理。 智能合约允许您编写可由计算机代码自动执行的合约。  
>
> 以太坊的通用性质允许在其之上构建任意数量的可能应用程序，这些应用程序都继承了在以太坊区块链上运行所带来的安全性和去中心化优势。

#### 4.5 ERC20 Tokens
> 除了以太币，人们还可以在以太坊上创建和使用自己的货币。 最常见的货币形式是 ***ERC20 代币***。 ERC20 代币是符合特定标准的智能合约。 开发者可以超越标准，但在制作自己的代币时应满足最低要求。 标准化允许数字钱包轻松支持所有类型的代币，而无需为创建的每个代币编写专门的代码。

#### 4.6 ERC721 and ERC1155 Tokens
> 这些也称为 NFTs。 这两个标准与 ERC20 类似，为创建 NFT 时应满足哪些要求提供了基准线。 它们也提供类似的好处，允许钱包和 NFT 市场立即与所有 NFT 系列兼容，因为它们都遵循这两个标准之一。

#### 4.7 总结与参考资料
> [1. A gentle introduction to Ethereum](https://bitsonblocks.net/2016/10/02/gentle-introduction-ethereum/)  
> [2. Ethereum Whitepaper](https://ethereum.org/en/whitepaper/)  
> [3. ERC-20 Tokens, Explained](https://cointelegraph.com/explained/erc-20-tokens-explained)  
> [4. Smart contracts - Simply Explained](https://www.youtube.com/watch?v=ZE2HxTmxfrI&ab_channel=SimplyExplained)  
> [5. What are Smart Contracts?](https://blockgeeks.com/guides/smart-contracts/)  
> [6. What Are ERC-20 Tokens on the Ethereum Network?](https://www.investopedia.com/news/what-erc20-and-what-does-it-mean-ethereum/)  



### 五、加密钱包

#### 5.1 地址(address)
> **地址**是使用密码学生成的一串文本，代表您在区块链上的账户。  
> 该地址可以与他人公开共享，这样做是完全安全的。 您可以从您的钱包地址发送和接收资金。  
> 基本上，地址是您在区块链上的唯一标识符，代表您的“帐户”。  
> 
> 以太坊地址的一个例子是：**0x01573Df433484fCBe6325a0c6E051Dc62Ab107D1**。

#### 5.2 私钥(private keys)
> 私钥是地址的对应物。 每个地址都有一个关联的私钥。 顾名思义，这是为了保密而不与任何人共享。  
> 
> 你可以把它想象成一个密码，一个非常强大的密码，它包含一堆字母和数字，可以让你**证明对你的地址的所有权**。 任何拥有私钥的人都可以从您的地址进行交易，即从您的地址向他们的地址汇款。  
> 
> 私钥看起来像这样：**E9873D79C6D87DC0FB6A5778633389F4453213303DA61F20BD67FC233AA33262**  
> 
> 如果您将**地址视为帐户的用户名**，那么**私钥就是它的密码**。 因此，分享你的地址是可以的，但永远不要分享你的私钥，否则有人可能会窃取你的资金——然后就无能为力了。  

**注意：由于区块链是分散的，因此没有“忘记密码”选项。 如果您丢失了私钥，您将无法访问您的帐户。 同样，如果有人偷了你的私钥，盗走了你的资金，你也无能为力。 确保此私钥的安全非常重要。**

> 对于开发人员，我们经常使用私钥作为我们代码库的一部分来执行某些交易，例如将我们自己的智能合约部署到以太坊网络。 当您还在学习时，我们强烈**建议您使用一个完全用于开发的单独帐户，而不是用于存储任何类型的资金。**  
> 不幸的是，新手开发者经常使用他们有资金的同一个账户，并且不小心公开分享他们的代码库——黑客可以在代码库中看到你的私钥并最终窃取资金。 请对此谨慎对待，引以为戒。

#### 5.3 助记词(seed phrase)
> 助记词就像主密码——**密码的密码！**  
> 
> 想像为密码管理器，比如 Lastpass 或 1Password。 这些应用程序在其中安全地存储您的其他应用程序的用户名和密码，并且它们本身也有密码。 因此，如果有人破解了您的密码管理器，他们也可以访问其中存储的所有帐户。  
> 
> **加密钱包有点像密码管理器**，您可以在其中管理多个区块链帐户。 如果私钥是单个帐户的密码，则助记词有点像该钱包的主密码。
> 
> 当您创建一个新的加密钱包时，您会看到一个助记词，您应该**绝对安全地存储和备份它**。 您从该钱包内生成的任何新帐户都将链接到助记词。 一个助记词将始终生成相同的帐户，每个帐户具有相同的私钥和地址。
> 
> 例如，如果您创建了一个钱包，然后在其中创建了 5 个帐户，您的助记词将管理所有 5 个帐户。如果您想切换到一个新钱包，您可以分别导入这 5 个钱包 - 通过使用它们各自的私钥 - 或者只使用助记词导入，它会重新生成相同的 5 个帐户。
> 
> 助记词的一个例子是：**dove lumber quote board young robust kit invite plastic regular skull history**

#### 5.4 加密钱包(crypto wallet)
> 加密钱包是您账户的管理者，主要是他们的私钥。 它们还允许您与去中心化应用程序交互，并允许通过钱包连接到 dApp，充当构建在区块链上的所有应用程序的单点登录。


#### 5.5 设置加密钱包
> 对于以太坊，有许多可用的钱包选项。 最容易上手且对开发人员最友好的是 **Metamask** 或 **Coinbase** 钱包。
> 
> 两者都是以太坊加密钱包，可以作为浏览器扩展或移动应用程序安装。   
> 其他替代方案包括 Trust Wallet、Atomic Wallet、Rainbow Wallet、Frame.sh 等。 
> 
> 您可以在下面找到下载链接。   
> [1. Metamask](https://metamask.io/download/)  
> [2. Coinbase Wallet](https://www.coinbase.com/wallet)  
> [3. Rainbow Wallet](https://rainbow.me/)  
> [4. Trust Wallet](https://trustwallet.com/)  
> [5. Atomic Wallet](https://atomicwallet.io/)  
> [6. Frame.sh](https://frame.sh/)  


### 六、开发IDE REMIX
![REMIX IDE](https://user-images.githubusercontent.com/16539849/173646901-81144afc-36aa-418c-be7f-70477b627ced.png)

#### 6.1 REMIX介绍
> Remix Solidity IDE 是一款**基于浏览器的IDE**。
> 它用于开发智能合约，也是目前比较推荐的一款开发以太坊智能合约的IDE，特别是对于新手来说。由于是基于浏览器的IDE，有一个很大的好处就是不用安装，也不用去安装Solidity运行环境，打开即用。
> 
> 官方网址：https://remix.ethereum.org/
> 
> Solidity IDE Remix(在线浏览器编辑器)提供在线编辑Solidity代码、基本的编译、部署至本地或测试网络、执行合约等功能。它是最早在以太坊上构建的开发工具，并拥有大量的扩展插件。

#### 6.2 REMIX导航
> 在左侧边栏中，您可以在<kbd><b>File Explorer(文件资源管理器)</b></kbd>、<kbd><b>Solidity Compiler(Solidity 编译器)</b></kbd>、<kbd><b>Deployer(部署器)</b></kbd>和<kbd><b>扩展面板</b></kbd>之间切换。  
> 在底部，有一个输出面板，显示编译、部署和函数调用的输出。  
> 中间是您将编辑代码的地方。 目前它显示的是 IDE 的主屏幕，但一旦我们打开一个文件，它就会变成代码编辑器。  

![REMIX导航](https://i.imgur.com/4RqBi40.png)

#### 6.3 REMIX工作流
> 在边栏中，如果您在<kbd><b>contracts</b></kbd>文件夹下查看 - Remix 附带 3 个基本智能合同，以帮助人们学习 Solidity。 让我们看一下 <kbd><b>1_Storage.sol</b></kbd>。

![1_Storage.sol](https://i.imgur.com/OdGQABf.png)

> 在文件资源管理器中，我们还可以看到创建新文件或目录、上传本地文件或从 Github 导入文件的选项。
> 
> 为了编译我们的合约，我们转到 <kbd><b>Solidity Compiler</b></kbd> 选项卡，我们将在侧边栏中看到类似这样的内容。

![Solidity Compiler](https://i.imgur.com/kr0a26J.png)

> 在这里，我们可以选择我们想要的<kbd><b>Compiler Version</b></kbd>，我们正在使用的智能合约编程语言（大多数情况下你只会使用 Solidity），以及一些进一步的配置选项。

注意：Remix 中列出的另一种编程语言 <kbd><b>Yul</b></kbd> 是一种低级语言。 它用于中间编译，比 Solidity 更接近硬件。 99% 的时间你不会在 Yul 中编码。 在此处阅读有关 Yul 的更多信息 - [https://docs.soliditylang.org/en/v0.8.9/yul.html](https://docs.soliditylang.org/en/v0.8.9/yul.html)

> 单击 <kbd><b>Compile 1_Storage.sol</b></kbd> 将编译合约并使其准备好部署。

![Compile 1_Storage.sol](https://i.imgur.com/KieTxyw.png)

> 移至 <kbd><b>Deployment</b></kbd> 选项卡，我们将在侧边栏中看到类似这样的内容。

![Deployment](https://i.imgur.com/svMiVS3.png)

> 这里首先要注意的是<kbd><b>Environment</b></kbd>。 Remix 附带一个 <kbd><b>Remix VM（London）</b></kbd>——它是在浏览器中运行 London Upgrade的以太坊虚拟机 (EVM) 的模拟器。 这允许快速测试和调试你的智能合约，只要你的合约不依赖于部署到真实以太坊网络的另一个合约。 值得庆幸的是，我们的存储合约没有，所以我们可以在 Remix VM 中对其进行测试。  
> 
> 要部署到实际网络，我们需要将<kbd><b>Environment</b></kbd> 更改为此处列出的其他选项之一。
>
> 与 <kbd><b>Remix VM（London）</b></kbd>一起，Remix 创建了一组假账户，全部加载了 100 ETH，用于测试。
> 
> 从下拉列表中选择 <kbd><b>1_Storage.sol</b></kbd> 合同，然后单击<kbd><b>Deploy</b></kbd>以部署合同。
> 
> 部署合约后，您将在<kbd><b>Deployed Contracts</b></kbd>部分看到它。
> - 现在可以在其中调用智能合约上的函数。
> 
> 调用 <kbd><b>retrieve</b></kbd> 函数将立即返回 <kbd><b>0</b></kbd> 值，这是 Solidity 中整数的默认值。

![Deployed Contracts](https://i.imgur.com/B0tBUt0.png)

> 同样，我们在输出面板中看到一些关于调用 <kbd><b>Storage.store</b></kbd> 的日志。 现在，如果我们再次尝试<kbd><b>retrieve</b></kbd>，输出将为 <kbd><b>5</b></kbd>。

![Storage.store](https://i.imgur.com/m3BwJCc.png)

> **注意 - 我们进行的这些函数调用/交易都没有打开您的数字钱包 (Metamask)。 这是因为我们目前正在 <kbd><b>Remix VM（London）</b></kbd>中进行测试，而这只是一个使用假账户的模拟器。 当部署到真实网络（测试网或主网）时，交易需要通过您的数字钱包进行确认和签名。**

#### 6.4 总结与参考资料
> 1. 浏览 [Remix IDE Docs 中的文档](https://remix-ide.readthedocs.io/en/latest/)  
> 2. 使用 Remix 附带的默认智能合约来处理工作流程

